<!-- ##### SECTION ./tmpl/DataDesc.sgml:Long_Description ##### -->
<para>In order to allow GRAS to send data over the network (or simply to
dupplicate it in SG), you have to describe the structure of data attached
with each message. This mecanism is stolen from NWS message passing
interface.</para>

<para>For each message, you have to declare a structure representing the
data to send as payload with the message.</para>

<refsect2>
  <title>Sending (or receiving) simple structures</title>
  <para>Let's imagin you want to declare a <command>STORE_STATE</command>
  message, which will send some data to the memory server for inclusion in
  the database. Here is the structure we want to send:</para>

<literallayout>
 struct state {
  char id[STATE_NAME_SIZE];
  int rec_size;
  int rec_count;
  double seq_no;
  double time_out;
 };
</literallayout>

  <para>And here is the structure description GRAS needs to be able to send
  this over the network:</para>

<literallayout>
 const static DataDescriptor stateDescriptor[] =
  {SIMPLE_MEMBER(CHAR_TYPE, STATE_NAME_SIZE, offsetof(struct state, id)),
   SIMPLE_MEMBER(INT_TYPE, 1, offsetof(struct state, rec_size)),
   SIMPLE_MEMBER(INT_TYPE, 1, offsetof(struct state, rec_count)),
   SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(struct state, seq_no)),
   SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(struct state, time_out))};
</literallayout>

  <para>Contrary to what one could think when you first see it, it's pretty
  easy. A structure descriptor is a list of descriptions, describing each
  field of the structure. For example, for the first field, you say that
  the base type is <command>CHAR_TYPE</command>, that there is
  <command>STATE_NAME_SIZE</command> element of this type and that it's
  position in the structure is computed by <command>offsetof(struct state,
  id)</command>. This leads to two remarks:</para> 

  <itemizedlist>
    <listitem>
      <para>it's impossible to send dynamic sized strings that way. It's a
      known limitation, but I think we can live with it.</para>
    </listitem>
    <listitem>
      <para>Yes, the <command>offsetof(struct state, id)</command>
      construction is C ANSI and is portable.</para>
    </listitem>
  </itemizedlist>
</refsect2>

<refsect2>
  <title>Sending (or receiving) complex structure</title>
  <para>How to send non-flat structures, do you ask? It's not harder. Let's
  imagin you want to send the following structure:</para>

<literallayout>
 typedef struct {
   unsigned long address;
   unsigned long port;
 } CliqueMember;

 typedef struct {
   char name[MAX_CLIQUE_NAME_SIZE];
   double whenGenerated;
   double instance;
   char skill[MAX_SKILL_SIZE];
   char options[MAX_OPTIONS_SIZE];
   double period;
   double timeOut;
   CliqueMember members[MAX_MEMBERS];
   unsigned int count;
   unsigned int leader;
 } Clique;
</literallayout>

  <para>As you can see, this structure contains an array of another user
  defined structure. To be able to send <command>struct Clique</command>,
  you have to describe each structures that way:</para>

<literallayout>
 static const DataDescriptor cliqueMemberDescriptor[] =
   {SIMPLE_MEMBER(UNSIGNED_LONG_TYPE, 1, offsetof(CliqueMember, address)),
    SIMPLE_MEMBER(UNSIGNED_LONG_TYPE, 1, offsetof(CliqueMember, port))};

 static const DataDescriptor cliqueDescriptor[] =
   {SIMPLE_MEMBER(CHAR_TYPE, MAX_CLIQUE_NAME_SIZE, offsetof(Clique, name)),
    SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(Clique, whenGenerated)),
    SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(Clique, instance)),
    SIMPLE_MEMBER(CHAR_TYPE, MAX_SKILL_SIZE, offsetof(Clique, skill)),
    SIMPLE_MEMBER(CHAR_TYPE, MAX_OPTIONS_SIZE, offsetof(Clique, options)),
    SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(Clique, period)),
    SIMPLE_MEMBER(DOUBLE_TYPE, 1, offsetof(Clique, timeOut)),
    {STRUCT_TYPE, MAX_MEMBERS, offsetof(Clique, members),
     (DataDescriptor *)&amp;cliqueMemberDescriptor, cliqueMemberDescriptorLength,
     PAD_BYTES(CliqueMember, port, unsigned long, 1)},
    SIMPLE_MEMBER(UNSIGNED_INT_TYPE, 1, offsetof(Clique, count)),
    SIMPLE_MEMBER(UNSIGNED_INT_TYPE, 1, offsetof(Clique, leader))};
</literallayout>

  <para>So, even if less natural, it is possible to send structures 
  containing structures with these tools.</para>

  <para>You can see that it's not only impossible to send dynamic-sized
  strings, it impossible to send dynamic-sized arrays. Here,
  <command>MAX_MEMBERS</command> is the maximum of members a clique can
  contain. In NWS, this value is defined to 100.  <warning><para>I'm not
  sure, but I think that all the 100 values are sent each time, even if
  there is only 3 non-null members. Yes, that's
  bad.</para></warning></para>

  <warning><para>The DataDescriptor_t MUST be const. Malloc'ing them and
  then casting them on argument passing IS NOT OK. This is because we get
  the number of elements in the array with the sizeof(dd)/sizeof(dd[0]).
  </para></warning>
</refsect2>


<!-- ##### SECTION ./tmpl/DataDesc.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/DataDesc.sgml:Short_Description ##### -->
Describing the data


<!-- ##### SECTION ./tmpl/DataDesc.sgml:Title ##### -->
DataDescriptor API


<!-- ##### SECTION ./tmpl/ErrLog.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/ErrLog.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/ErrLog.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/ErrLog.sgml:Title ##### -->
ErrLog


<!-- ##### SECTION ./tmpl/Socks.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/Socks.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/Socks.sgml:Short_Description ##### -->
Handling sockets


<!-- ##### SECTION ./tmpl/Socks.sgml:Title ##### -->
Sockets API


<!-- ##### SECTION ./tmpl/comm_callbacks.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_callbacks.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_callbacks.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/comm_callbacks.sgml:Title ##### -->
comm_callbacks


<!-- ##### SECTION ./tmpl/comm_cb.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_cb.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_cb.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/comm_cb.sgml:Title ##### -->
comm_cb


<!-- ##### SECTION ./tmpl/comm_datadesc_expert.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_datadesc_expert.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_datadesc_expert.sgml:Short_Description ##### -->
Advanced ways to describe data (for experts)


<!-- ##### SECTION ./tmpl/comm_datadesc_expert.sgml:Title ##### -->
Advanced Data description


<!-- ##### SECTION ./tmpl/comm_dd_cbps.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_dd_cbps.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/comm_dd_cbps.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/comm_dd_cbps.sgml:Title ##### -->
Data description callbacks persistant state


<!-- ##### SECTION ./tmpl/config.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/config.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/config.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/config.sgml:Title ##### -->
config


<!-- ##### SECTION ./tmpl/dd_cbps.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dd_cbps.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dd_cbps.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/dd_cbps.sgml:Title ##### -->
Data description callbacks persistant state


<!-- ##### SECTION ./tmpl/dd_internal.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dd_internal.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dd_internal.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/dd_internal.sgml:Title ##### -->
Implementation of data description


<!-- ##### SECTION ./tmpl/dico.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dico.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dico.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/dico.sgml:Title ##### -->
dico


<!-- ##### SECTION ./tmpl/dynar.sgml:Long_Description ##### -->
<para>
This module provide the quite usual dynamic array facility.
</para>


<!-- ##### SECTION ./tmpl/dynar.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/dynar.sgml:Short_Description ##### -->
Dynamic array


<!-- ##### SECTION ./tmpl/dynar.sgml:Title ##### -->
dynar


<!-- ##### SECTION ./tmpl/gras-overview.sgml:Long_Description ##### -->
    <para>This document introduce the GRAS library (<emphasis>Grid Reality
    And Simulation</emphasis>, or according to my english dictionary,
    <emphasis>Generally Recognized As Safe</emphasis> ;).</para>
    
    <refsect2>
      <title>Overview</title>
      <para>The purpose of the GRAS is to allow the developpement of
      distributed programs which will work with as few as possible
      modification both on the SimGrid simulator (SG), and in the Real Life
      (RL).</para>

      <para>Here are the problems when you want to do so:
        <itemizedlist>
	  <listitem>
	    <para>Communication in SG is done by passing tasks, while in
	    RL, you have to deal with sockets (or any wrapper to it).</para>
	  </listitem>
	  <listitem><para>In RL, each process should provide a main()
	    function, and it's obviously not the case in SG.</para>
	  </listitem>
	</itemizedlist>
      </para>
    </refsect2>
    <refsect2>
      <title>Application class target</title>
      <para>If you want to run your code both in RL and in SG, you won't be
      able to use the full set of features offered by any of those two
      worlds. GRAS tries to provide a suffisent set of features to develop
      your application, and implement them in both worlds.</para>

      <para>GRAS uses the paradigm of <emphasis>event-driven 
      programming</emphasis>, which is an extension to the message-passing
      one. Any process of a typical event-driven application declares
      callback to incoming events, which can be messages from other
      processes, timers or others.</para>

      <para>All messages have an header, specifying its type, and attached
      data, represented as one or several C structures. In order to send
      the data over the network in RL, a type-description mecanism is
      provided, and the RL version of GRAS implements CDR
      functionnalities. That is to say that the data are sent in the native
      format of the sender host, and converted on the destination host only
      if needed.</para>

      <para>In order to not reimplement the wheel, GRAS use existing code,
      and adapt them to make them work together. The SG version naturally
      use the SimGrid toolkit, while the RL version is based over the
      communication library used in NWS (note that this library was somehow
      modified, since the previous version use XDR, ie both the sender and
      the receiver convert the data from/to a so called network
      format). That's why some basic knowledge about how NWS work is
      supposed in this document. But don't worry, you only have to know the
      basics about NWS, the internals needed to understand the document
      will be presented when needed.</para>
    </refsect2>


<!-- ##### SECTION ./tmpl/gras-overview.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras-overview.sgml:Short_Description ##### -->
Overview of the GRAS library


<!-- ##### SECTION ./tmpl/gras-overview.sgml:Title ##### -->
Overview


<!-- ##### SECTION ./tmpl/gras.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gras.sgml:Title ##### -->
gras


<!-- ##### SECTION ./tmpl/gras_private.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras_private.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras_private.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/gras_private.sgml:Title ##### -->
gras_private


<!-- ##### SECTION ./tmpl/gras_rl.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras_rl.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/gras_rl.sgml:Short_Description ##### -->
Implementation of GRAS suited for real life.


<!-- ##### SECTION ./tmpl/gras_rl.sgml:Title ##### -->
RL


<!-- ##### SECTION ./tmpl/gras_sg.sgml:Long_Description ##### -->
<para>
  SimGrid was designed to ease the comparison of algorithms and
  heuristics. That way, a lot of complicated notion from the system layer
  were volontary left off. For example, migrating a process from an host to
  another is as easy as: MSG_process_change_host(process, new_host).
</para>

<para>
  No need to tell that performing this operation on real platform is really
  harder. This simplification is a very good thing when you want to rapidly
  prototype code, but makes things somehow more complicated in GRAS since
  we want to have a realistic API, since it have to be implemented in
  reality also.
</para>

<para>
  The best example of complexity in GRAS_SG induced by simplicity in
  SimGrid is the sockets handling. There is no "socket" in SG, but only
  m_channel_t. In contrary to sockets from RL, no special treatment is
  needed for a process before writing or reading on/from a channel. So, a
  given channel can be pooled by more than one process. Likewise, you can
  send data to a channel that nobody is actually listening to.
</para>

<para>
  The SG implementation of GRAS repport as an error the fact that nobody is
  listening to the socket when trying to open a socket, or send stuff using
  a previously openned socket. That way, the SG version can be used to
  debug all syncronization issues. For that, we store mainly the PID of
  both the sender and the receiver in the socket structure, and then
  resolve PID->process at the lastest moment. This search is a bit
  expensive, but as long as there is no real garbage collection in SG, with
  the information "dead process" within the structure, it's the only
  solution to make sure that we won't dereference pointers to an old freed
  structure when the process on the other side of the structure did finish
  since the creation of the socket.
</para>

<para>
  As said in the overview, the processes can declare to hear on several
  sockets, but all incoming messages are handled by the same loop. So, we
  can use only one channel per process, and use a table on each host to
  determine to which process a message should be delivered depending on the
  socket number provided by the sender.
</para>


<!-- ##### SECTION ./tmpl/gras_sg.sgml:See_Also ##### -->
<para>
RL, the implementation suited for real life.
</para>

<!--
Local variables:
sgml-parent-document:\.\./gras-docs\.sgml
sgml-omittag:t
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->


<!-- ##### SECTION ./tmpl/gras_sg.sgml:Short_Description ##### -->
Implementation of GRAS on top of the simulator.


<!-- ##### SECTION ./tmpl/gras_sg.sgml:Title ##### -->
SG


<!-- ##### SECTION ./tmpl/nws_comm.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/nws_comm.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/nws_comm.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/nws_comm.sgml:Title ##### -->
nws_comm


<!-- ##### SECTION ./tmpl/trp_socks.sgml:Long_Description ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/trp_socks.sgml:See_Also ##### -->
<para>

</para>


<!-- ##### SECTION ./tmpl/trp_socks.sgml:Short_Description ##### -->



<!-- ##### SECTION ./tmpl/trp_socks.sgml:Title ##### -->
Sockets


<!-- ##### MACRO BEGIN_DECL ##### -->
<para>

</para>


<!-- ##### MACRO CCRITICAL0 ##### -->
<para>

</para>

@c: 
@f: 

<!-- ##### MACRO CCRITICAL1 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 

<!-- ##### MACRO CCRITICAL2 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 

<!-- ##### MACRO CCRITICAL3 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 

<!-- ##### MACRO CCRITICAL4 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 

<!-- ##### MACRO CCRITICAL5 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 

<!-- ##### MACRO CDEBUG0 ##### -->
<para>

</para>

@c: 
@f: 

<!-- ##### MACRO CDEBUG1 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 

<!-- ##### MACRO CDEBUG2 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 

<!-- ##### MACRO CDEBUG3 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 

<!-- ##### MACRO CDEBUG4 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 

<!-- ##### MACRO CDEBUG5 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 

<!-- ##### MACRO CERROR0 ##### -->
<para>

</para>

@c: 
@f: 

<!-- ##### MACRO CERROR1 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 

<!-- ##### MACRO CERROR2 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 

<!-- ##### MACRO CERROR3 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 

<!-- ##### MACRO CERROR4 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 

<!-- ##### MACRO CERROR5 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 

<!-- ##### MACRO CINFO0 ##### -->
<para>

</para>

@c: 
@f: 

<!-- ##### MACRO CINFO1 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 

<!-- ##### MACRO CINFO2 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 

<!-- ##### MACRO CINFO3 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 

<!-- ##### MACRO CINFO4 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 

<!-- ##### MACRO CINFO5 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 

<!-- ##### MACRO CLOG0 ##### -->
<para>

</para>

@c: 
@p: 
@f: 

<!-- ##### MACRO CLOG1 ##### -->
<para>

</para>

@c: 
@p: 
@f: 
@a1: 

<!-- ##### MACRO CLOG2 ##### -->
<para>

</para>

@c: 
@p: 
@f: 
@a1: 
@a2: 

<!-- ##### MACRO CLOG3 ##### -->
<para>

</para>

@c: 
@p: 
@f: 
@a1: 
@a2: 
@a3: 

<!-- ##### MACRO CLOG4 ##### -->
<para>

</para>

@c: 
@p: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 

<!-- ##### MACRO CLOG5 ##### -->
<para>

</para>

@c: 
@p: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 

<!-- ##### MACRO CLOG6 ##### -->
<para>

</para>

@c: 
@p: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 
@a6: 

<!-- ##### MACRO CRITICAL0 ##### -->
<para>

</para>

@f: 

<!-- ##### MACRO CRITICAL1 ##### -->
<para>

</para>

@f: 
@a1: 

<!-- ##### MACRO CRITICAL2 ##### -->
<para>

</para>

@f: 
@a1: 
@a2: 

<!-- ##### MACRO CRITICAL3 ##### -->
<para>

</para>

@f: 
@a1: 
@a2: 
@a3: 

<!-- ##### MACRO CRITICAL4 ##### -->
<para>

</para>

@f: 
@a1: 
@a2: 
@a3: 
@a4: 

<!-- ##### MACRO CRITICAL5 ##### -->
<para>

</para>

@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 

<!-- ##### MACRO CWARNING6 ##### -->
<para>

</para>

@c: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 
@a6: 

<!-- ##### FUNCTION CallAddr ##### -->
<para>

</para>

@addr: 
@Param2: 
@sock: 
@timeOut: 
@Returns: 

<!-- ##### FUNCTION CloseSocket ##### -->
<para>

</para>

@sock: 
@waitForPeer: 
@Returns: 

<!-- ##### FUNCTION ConvertData ##### -->
<para>

</para>

@destination: 
@source: 
@description: 
@length: 
@sourceFormat: 

<!-- ##### FUNCTION CreateLocalChild ##### -->
<para>

</para>

@pid: 
@parentToChild: 
@childToParent: 
@Returns: 

<!-- ##### FUNCTION DROP_SOCKET ##### -->
<para>

</para>

@sock: 
@Returns: 

<!-- ##### FUNCTION DataSize ##### -->
<para>

</para>

@description: 
@length: 
@format: 
@Returns: 

<!-- ##### ENUM DataTypes ##### -->
<para>

</para>

@CHAR_TYPE: 
@DOUBLE_TYPE: 
@FLOAT_TYPE: 
@INT_TYPE: 
@LONG_TYPE: 
@SHORT_TYPE: 
@UNSIGNED_INT_TYPE: 
@UNSIGNED_LONG_TYPE: 
@UNSIGNED_SHORT_TYPE: 
@STRUCT_TYPE: 
@LAST_TYPE: 

<!-- ##### FUNCTION DifferentFormat ##### -->
<para>

</para>

@whatType: 
@Returns: 

<!-- ##### FUNCTION DifferentOrder ##### -->
<para>

</para>

@Returns: 

<!-- ##### FUNCTION DifferentSize ##### -->
<para>

</para>

@whatType: 
@Returns: 

<!-- ##### MACRO END_DECL ##### -->
<para>

</para>


<!-- ##### MACRO EODD ##### -->
<para>

</para>


<!-- ##### FUNCTION EstablishAnEar ##### -->
<para>

</para>

@Param1: 
@Param2: 
@ear: 
@earPort: 
@Returns: 

<!-- ##### ENUM FormatTypes ##### -->
<para>

</para>

@HOST_FORMAT: 
@NETWORK_FORMAT: 

<!-- ##### MACRO GRAS_LOG_MAYDAY ##### -->
<para>

</para>


<!-- ##### MACRO GRAS_LOG_ROOT_CAT ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_DLFCN_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_INTTYPES_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_LIBPTHREAD ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_MEMORY_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_STDINT_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_STDLIB_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_STRINGS_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_STRING_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_SYS_STAT_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_SYS_TYPES_H ##### -->
<para>

</para>


<!-- ##### MACRO HAVE_UNISTD_H ##### -->
<para>

</para>


<!-- ##### FUNCTION HomogenousConvertData ##### -->
<para>

</para>

@destination: 
@source: 
@whatType: 
@repetitions: 
@sourceFormat: 

<!-- ##### FUNCTION HomogenousDataSize ##### -->
<para>

</para>

@whatType: 
@repetitions: 
@format: 
@Returns: 

<!-- ##### TYPEDEF IPAddress ##### -->
<para>

</para>


<!-- ##### FUNCTION IPAddressImage ##### -->
<para>

</para>

@addr: 
@Returns: 

<!-- ##### FUNCTION IPAddressImage_r ##### -->
<para>

</para>

@addr: 
@Returns: 

<!-- ##### FUNCTION IPAddressMachine ##### -->
<para>

</para>

@addr: 
@Returns: 

<!-- ##### FUNCTION IPAddressMachine_r ##### -->
<para>

</para>

@addr: 
@Returns: 

<!-- ##### MACRO IPAddressValue ##### -->
<para>

</para>

@machineOrAddress: 
@address: 

<!-- ##### FUNCTION IPAddressValues ##### -->
<para>

</para>

@machineOrAddress: 
@addressList: 
@atMost: 
@Returns: 

<!-- ##### FUNCTION IncomingRequest ##### -->
<para>

</para>

@timeOut: 
@sd: 
@ldap: 
@Returns: 

<!-- ##### FUNCTION IsOkay ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION IsPipe ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### MACRO IsValidIP ##### -->
<para>

</para>

@machineOrAddress: 

<!-- ##### MACRO LOG6 ##### -->
<para>

</para>

@p: 
@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 
@a6: 

<!-- ##### FUNCTION MyMachineName ##### -->
<para>

</para>

@Returns: 

<!-- ##### MACRO NO_SOCKET ##### -->
<para>

</para>


<!-- ##### FUNCTION NotifyOnDisconnection ##### -->
<para>

</para>

@notifyFn: 

<!-- ##### FUNCTION OpenClientSocket ##### -->
<para>

</para>

@addr: 
@Param2: 
@sock: 
@Returns: 

<!-- ##### FUNCTION OpenServerSocket ##### -->
<para>

</para>

@Param1: 
@Param2: 
@ear: 
@earPort: 
@Returns: 

<!-- ##### MACRO PACKAGE ##### -->
<para>

</para>


<!-- ##### MACRO PACKAGE_BUGREPORT ##### -->
<para>

</para>


<!-- ##### MACRO PACKAGE_NAME ##### -->
<para>

</para>


<!-- ##### MACRO PACKAGE_STRING ##### -->
<para>

</para>


<!-- ##### MACRO PACKAGE_TARNAME ##### -->
<para>

</para>


<!-- ##### MACRO PACKAGE_VERSION ##### -->
<para>

</para>


<!-- ##### MACRO PAD_BYTES ##### -->
<para>

</para>

@structType: 
@lastMember: 
@memberType: 
@repetitions: 

<!-- ##### FUNCTION PassSocket ##### -->
<para>

</para>

@sock: 
@child: 
@Returns: 

<!-- ##### FUNCTION Peer ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION PeerName ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION PeerName_r ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION ReverseData ##### -->
<para>

</para>

@destination: 
@source: 
@whatType: 
@repetitions: 
@format: 

<!-- ##### MACRO SIMPLE_DATA ##### -->
<para>

</para>

@type: 
@repetitions: 

<!-- ##### MACRO SIMPLE_MEMBER ##### -->
<para>

</para>

@type: 
@repetitions: 
@offset: 

<!-- ##### MACRO SIMPLE_TYPE_COUNT ##### -->
<para>

</para>


<!-- ##### MACRO STDC_HEADERS ##### -->
<para>

</para>


<!-- ##### TYPEDEF Socket ##### -->
<para>

</para>


<!-- ##### FUNCTION SocketFailure ##### -->
<para>

</para>

@sig: 

<!-- ##### USER_FUNCTION SocketFunction ##### -->
<para>

</para>

@Param1: 

<!-- ##### FUNCTION SocketInUse ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION SocketIsAvailable ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### MACRO VERSION ##### -->
<para>

</para>


<!-- ##### MACRO WARNING6 ##### -->
<para>

</para>

@f: 
@a1: 
@a2: 
@a3: 
@a4: 
@a5: 
@a6: 

<!-- ##### USER_FUNCTION grasCallbackFunction ##### -->
<para>

</para>

@sd: 
@msgType: 
@vdata: 

<!-- ##### FUNCTION grasCloseSocket ##### -->
<para>

</para>

@sock: 
@Returns: 

<!-- ##### FUNCTION grasDataDescCmp ##### -->
<para>

</para>

@dd1: 
@c1: 
@dd2: 
@c2: 
@Returns: 
@description: 

<!-- ##### FUNCTION grasDataDescCount ##### -->
<para>

</para>

@description: 
@Returns: 

<!-- ##### FUNCTION grasDataRecv ##### -->
<para>

</para>

@sd: 
@data: 
@description: 
@description_length: 
@repetition: 
@Returns: 

<!-- ##### FUNCTION grasDataSend ##### -->
<para>

</para>

@sd: 
@data: 
@description: 
@description_length: 
@repetition: 
@Returns: 

<!-- ##### FUNCTION grasDataSize ##### -->
<para>

</para>

@description: 
@ft: 
@Returns: 

<!-- ##### ENUM grasError_t ##### -->
<para>

</para>

@no_error: 
@malloc_error: 
@mismatch_error: 
@sanity_error: 
@system_error: 
@network_error: 
@timeout_error: 
@thread_error: 
@unknown_error: 

<!-- ##### FUNCTION grasLock ##### -->
<para>

</para>

@Returns: 

<!-- ##### TYPEDEF grasMessageType_t ##### -->
<para>

</para>


<!-- ##### FUNCTION grasMsgDiscard ##### -->
<para>

</para>

@sd: 
@size: 

<!-- ##### FUNCTION grasMsgEntryGet ##### -->
<para>

</para>

@id: 
@Returns: 

<!-- ##### TYPEDEF grasMsgEntry_t ##### -->
<para>

</para>


<!-- ##### FUNCTION grasMsgFree ##### -->
<para>

</para>

@msg: 

<!-- ##### FUNCTION grasMsgHandle ##### -->
<para>

</para>

@timeOut: 

<!-- ##### FUNCTION grasMsgHeaderNew ##### -->
<para>

</para>

@msgId: 
@dataSize: 
@seqCount: 
@Returns: 

<!-- ##### FUNCTION grasMsgNew ##### -->
<para>

</para>

@msgId: 
@free_data_on_free: 
@seqCount: 
@Varargs: 
@Returns: 

<!-- ##### FUNCTION grasMsgRecv ##### -->
<para>

</para>

@msg: 
@timeout: 
@Returns: 
@sd: 

<!-- ##### FUNCTION grasMsgRegister ##### -->
<para>

</para>

@message: 
@name: 
@sequence_count: 
@Varargs: 
@Returns: 

<!-- ##### FUNCTION grasMsgSend ##### -->
<para>

</para>

@sd: 
@message: 
@sequence_count: 
@Varargs: 
@Returns: 

<!-- ##### FUNCTION grasMsgWait ##### -->
<para>

</para>

@sd: 
@timeout: 
@message: 
@sequence_count: 
@Varargs: 
@Returns: 

<!-- ##### FUNCTION grasMyMachineName ##### -->
<para>

</para>

@Returns: 

<!-- ##### FUNCTION grasOpenClientSocket ##### -->
<para>

</para>

@host: 
@Param2: 
@sock: 
@Returns: 

<!-- ##### FUNCTION grasOpenServerSocket ##### -->
<para>

</para>

@Param1: 
@Param2: 
@sock: 
@Returns: 

<!-- ##### MACRO grasPROTOCOL ##### -->
<para>

</para>


<!-- ##### FUNCTION grasPeerGetAddress ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION grasPeerGetName ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION grasRecvData ##### -->
<para>

</para>

@sd: 
@data: 
@description: 
@Returns: 

<!-- ##### FUNCTION grasRegisterCallback ##### -->
<para>

</para>

@message: 
@TTL: 
@cb: 

<!-- ##### FUNCTION grasSendData ##### -->
<para>

</para>

@sd: 
@data: 
@description: 
@Returns: 

<!-- ##### FUNCTION grasUnlock ##### -->
<para>

</para>

@Returns: 

<!-- ##### FUNCTION grasUserdataGet ##### -->
<para>

</para>


<!-- ##### MACRO grasUserdataNew ##### -->
<para>

</para>

@type: 

<!-- ##### FUNCTION grasUserdataSet ##### -->
<para>

</para>

@ud: 

<!-- ##### FUNCTION gras_datadesc_cmp ##### -->
<para>

</para>

@d1: 
@d2: 
@Returns: 
@dd1: 
@c1: 
@dd2: 
@c2: 

<!-- ##### FUNCTION gras_datadesc_copy_data ##### -->
<para>

</para>

@dd: 
@c: 
@data: 

<!-- ##### MACRO gras_datadesc_declare_array ##### -->
<para>

</para>

@name: 
@elm_type: 
@size: 
@code: 

<!-- ##### FUNCTION gras_datadesc_declare_array_cb ##### -->
<para>

</para>

@name: 
@element_type: 
@fixed_size: 
@dynamic_size: 
@post: 
@code: 
@Returns: 

<!-- ##### FUNCTION gras_datadesc_declare_ref_cb ##### -->
<para>

</para>

@name: 
@referenced_type: 
@discriminant: 
@post: 
@code: 
@Returns: 

<!-- ##### MACRO gras_datadesc_declare_ref_disc ##### -->
<para>

</para>

@name: 
@discriminant: 
@code: 

<!-- ##### MACRO gras_datadesc_declare_struct_add_code ##### -->
<para>

</para>

@struct_code: 
@field_name: 
@field_type_code: 

<!-- ##### FUNCTION gras_datadesc_declare_struct_add_code_cb ##### -->
<para>

</para>

@struct_code: 
@field_name: 
@field_code: 
@pre_cb: 
@post_cb: 
@Returns: 

<!-- ##### MACRO gras_datadesc_declare_struct_add_name ##### -->
<para>

</para>

@struct_code: 
@field_name: 
@field_type_name: 

<!-- ##### FUNCTION gras_datadesc_declare_struct_add_name_cb ##### -->
<para>

</para>

@struct_code: 
@field_name: 
@field_type_name: 
@pre_cb: 
@post_cb: 
@Returns: 

<!-- ##### FUNCTION gras_datadesc_declare_struct_append_name ##### -->
<para>

</para>

@struct_type: 
@name: 
@field_type_name: 
@Returns: 

<!-- ##### FUNCTION gras_datadesc_declare_struct_cb ##### -->
<para>

</para>

@name: 
@pre_cb: 
@post_cb: 
@code: 
@Returns: 

<!-- ##### MACRO gras_datadesc_declare_union_add_code ##### -->
<para>

</para>

@union_code: 
@field_name: 
@field_type_code: 

<!-- ##### FUNCTION gras_datadesc_declare_union_add_code_cb ##### -->
<para>

</para>

@union_code: 
@field_name: 
@field_code: 
@pre_cb: 
@post_cb: 
@Returns: 

<!-- ##### MACRO gras_datadesc_declare_union_add_name ##### -->
<para>

</para>

@union_code: 
@field_name: 
@field_type_name: 

<!-- ##### FUNCTION gras_datadesc_declare_union_add_name_cb ##### -->
<para>

</para>

@union_code: 
@field_name: 
@field_type_name: 
@pre_cb: 
@post_cb: 
@Returns: 

<!-- ##### FUNCTION gras_datadesc_declare_union_append_name ##### -->
<para>

</para>

@union_type: 
@name: 
@field_type_name: 
@Returns: 

<!-- ##### FUNCTION gras_datadesc_declare_union_cb ##### -->
<para>

</para>

@name: 
@field_count: 
@post: 
@code: 
@Returns: 

<!-- ##### FUNCTION gras_datadesc_from_nws ##### -->
<para>

</para>

@name: 
@desc: 
@howmany: 
@code: 
@Returns: 
@dst: 

<!-- ##### FUNCTION gras_datadesc_parse ##### -->
<para>

</para>

@name: 
@Cdefinition: 
@dst: 
@Returns: 
@code: 
@def: 

<!-- ##### FUNCTION gras_ddt_free ##### -->
<para>

</para>

@type: 

<!-- ##### FUNCTION gras_ddt_get_by_code ##### -->
<para>

</para>

@code: 
@type: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_get_by_name ##### -->
<para>

</para>

@name: 
@type: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_array ##### -->
<para>

</para>

@name: 
@element_type: 
@fixed_size: 
@dynamic_size: 
@post: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_from_nws ##### -->
<para>

</para>

@name: 
@desc: 
@howmany: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_ignored ##### -->
<para>

</para>

@name: 
@default_value: 
@free_func: 
@size: 
@alignment: 
@post: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_parse ##### -->
<para>

</para>

@name: 
@C_definition: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_ref ##### -->
<para>

</para>

@name: 
@referenced_type: 
@discriminant: 
@post: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_scalar ##### -->
<para>

</para>

@name: 
@type: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_struct ##### -->
<para>

</para>

@name: 
@pre: 
@post: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_struct_append ##### -->
<para>

</para>

@struct_type: 
@name: 
@field_type: 
@pre: 
@post: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_union ##### -->
<para>

</para>

@name: 
@field_count: 
@post: 
@dst: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_new_union_append ##### -->
<para>

</para>

@union_type: 
@name: 
@field_type: 
@pre: 
@post: 
@Returns: 

<!-- ##### FUNCTION gras_ddt_register ##### -->
<para>

</para>

@type: 
@Returns: 

<!-- ##### FUNCTION gras_dict_cursor_next ##### -->
<para>

</para>

@cursor: 
@Returns: 

<!-- ##### FUNCTION gras_dict_insert ##### -->
<para>

</para>

@head: 
@key: 
@data: 
@free_ctn: 
@Returns: 

<!-- ##### FUNCTION gras_dict_insert_ext ##### -->
<para>

</para>

@head: 
@key: 
@key_len: 
@data: 
@free_ctn: 
@Returns: 

<!-- ##### FUNCTION gras_dict_retrieve ##### -->
<para>

</para>

@head: 
@key: 
@data: 
@Returns: 

<!-- ##### FUNCTION gras_dict_retrieve_ext ##### -->
<para>

</para>

@head: 
@key: 
@key_len: 
@data: 
@Returns: 

<!-- ##### FUNCTION gras_dynar_first ##### -->
<para>

</para>

@dynar: 
@cursor: 
@Returns: 

<!-- ##### FUNCTION gras_dynar_next ##### -->
<para>

</para>

@dynar: 
@cursor: 
@whereto: 
@Returns: 

<!-- ##### FUNCTION gras_lock ##### -->
<para>

</para>

@Returns: 

<!-- ##### FUNCTION gras_log_parent_set ##### -->
<para>

</para>

@cat: 
@parent: 

<!-- ##### FUNCTION gras_log_threshold_set ##### -->
<para>

</para>

@cat: 
@thresholdPriority: 

<!-- ##### FUNCTION gras_msg_discard ##### -->
<para>

</para>

@sd: 
@size: 

<!-- ##### FUNCTION gras_msg_free ##### -->
<para>

</para>

@msg: 

<!-- ##### FUNCTION gras_msg_new ##### -->
<para>

</para>

@msgId: 
@free_data_on_free: 
@seqCount: 
@Varargs: 
@Returns: 

<!-- ##### FUNCTION gras_msgtype_register ##### -->
<para>

</para>

@msgId: 
@name: 
@sequence_count: 
@Varargs: 
@Returns: 

<!-- ##### FUNCTION gras_sock_client_open ##### -->
<para>

</para>

@host: 
@Param2: 
@sock: 
@Returns: 

<!-- ##### FUNCTION gras_sock_close ##### -->
<para>

</para>

@sock: 
@Returns: 

<!-- ##### FUNCTION gras_sock_get_peer_addr ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION gras_sock_get_peer_name ##### -->
<para>

</para>

@sd: 
@Returns: 

<!-- ##### FUNCTION gras_sock_server_open ##### -->
<para>

</para>

@Param1: 
@Param2: 
@sock: 
@Returns: 

<!-- ##### FUNCTION gras_unlock ##### -->
<para>

</para>

@Returns: 

