/*! \page install Java Binding

\section bindings_binding_java_install How to install Simgrid-java

To use java with Simgrid you have to install some dependencies:
 \li Simgrid (see <a href="http://simgrid.gforge.inria.fr/simgrid/3.7/doc/install.html">install
     Simgrid</a>). You should set the SIMGRID_ROOT environment
     variable to the path where you installed SimGrid.
 \li Java JDK packages, such as sun-java6-jdk (with libgcj10-dev or
another version of gcj) or openjdk6. For maximal performance and
scalability, use a coroutine-enabled JVM (see
\ref bindings_binding_java_coroutines).
 
Then Download and install package Simgrid-java:
\verbatim
git clone git://scm.gforge.inria.fr/simgrid/simgrid-java.git
cd simgrid-java
cmake -DCMAKE_INSTALL_PREFIX=$HOME/Install/simgrid-java/ .
make install
\endverbatim
 
Cmake output
\verbatim
-- SITE        : Linux_2.6.38-8-generic_x86_64
-- BUILDNAME   : Simgrid-Java
-- Looking for lib SimGrid
-- Looking for lib SimGrid - found
-- Simgrid version : 3.6
-- Looking for gras.h
-- Looking for gras.h - found
-- Found Tesh: /home/user/Bureau/simgrid/git/bin/tesh
-- Found gras_stub_generator: /home/user/Bureau/simgrid/git/bin/gras_stub_generator
-- Java version 1.6.0.22 configured successfully!
-- Looking for jni.h
-- Looking for jni.h - found
-- Add flags -I/usr/lib/jvm/java-6-openjdk/include
-- Looking for jni_md.h
-- Looking for jni_md.h - found
-- Found javac: /usr/bin/javac
-- Found jar: /usr/bin/jar
-- Configuring done
-- Generating done
-- Build files have been written to: /home/user/workspace/simgrid-java/build
\endverbatim

\section bindings_binding_java_use How to use Simgrid-java

To execute the examples you need to add the path where you installed
the generated libSG_java library (<build_dir>/lib) and libsimgrid
($SIMGRID_ROOT/lib) into the LD_LIBRARY_PATH.

Be careful on Mac, this variable is called DYLD_LIBRARY_PATH and not
LD_LIBRARY_PATH.

\verbatim
$ export SIMGRID_ROOT="$HOME/Install/simgrid/"
$ export SIMGRID_JAVA_ROOT="$HOME/Install/simgrid-java"
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$SIMGRID_ROOT/lib:$SIMGRID_JAVA_ROOT/java
$ cd examples
$ java -cp .:../simgrid.jar basic/BasicTest platform.xml basic/basicDeployment.xml
\endverbatim








\section bindings_binding_java_coroutines How to use the coroutines context factory

There is two main motivations to use the coroutine variant of SimGrid
Java bindings: it's about 5 times faster than the default thread-based
context factory, and the amount of runnable processes is then only
limited by the amount of RAM that you have. The drawbacks are that it
requires a specific and rather experimental JVM to run, and that this
context factory itself remains a bit experimental so far.

\subsection  bindings_java_coro_install Getting a mlvm JVM

You need to get a patched JVM from <a href="http://ssw.jku.at/General/Staff/LS/coro/">here</a>
(many thanks to Lukas Stadler for this work!). 

You can either get a prebuilt binary, or recompile your own JVM. Make
sure to get a coro-simple version, as we don't need to serialize nor
migrate stacks in SimGrid. You should be able to follow the README.txt
that you'll get in the repository, but here is how we did it, just in
case. The instructions are given for a debian or Ubuntu box, but I
think you should manage to convert it to your system quite easily.
 
 -# Install mercurial and some dependencies
\verbatim 
sudo apt-get install mercurial ksh libfreetype6-dev libcups2-dev libasound2-dev gawk openjdk-7-jdk libxext-dev libxrender-dev libxtst-dev
# Grab the forest extension: we need to source-install it
hg clone https://bitbucket.org/gxti/hgforest hgforest \endverbatim
\endverbatim
 -# Configure the Forest extension: Edit ~/.hgrc and paste the
    following lines (beware of changing the /path/to/forest.py):
\verbatim
[extensions]
forest=/path/to/forest.py
\endverbatim
 -# Prepare the source code
\verbatim 
# create a working directory, and enter it
mkdir davinci; cd davinci

# Grab the sources
hg fclone http://hg.openjdk.java.net/hsx/hotspot-comp sources
# Grab the patches
hg fclone http://hg.openjdk.java.net/mlvm/mlvm patches

# Link the patch directories into the sources
patches/make/link-patch-dirs.sh sources patches
# Check that it worked
ls -il patches/hotspot/series sources/hotspot/.hg/patches/series

# Fetches the guards (patches) to apply: 
export davinci=$(pwd) guards="buildable testable coro-simple"
# (if a1 does not work) edit patches/make/Makefile and add coro-simple to GLOBAL_GUARDS
sh patches/make/each-patch-repo.sh hg qselect --reapply $guards '$(sh $davinci/patches/make/current-release.sh)'
\endverbatim	       
 -# Compile it all
\verbatim
# Prepare the sources
(cd patches/make; make setup && make force && make && make FORCE_VERSIONS=1)

unset LD_LIBRARY_PATH
export ALT_BOOTDIR=/usr/lib/jvm/java-7-openjdk-amd64/
# Check that everything is fine
make sanity
# Go for it
make all
\endverbatim

\subsection  bindings_java_coro_use Using coroutine contexts

SimGrid Java will automatically switch to the coroutine context
factory if your JVM support it, so you will just need to execute your
simulation with the correct JVM. The selected context factory gets
displayed when enabling the verbose logs of jmsg
(--log=jmsg.thres:verbose in the following).
\verbatim
$ $PATH_TO_COROUTINE_JVM/java -cp .:../simgrid.jar --log=jmsg.thres:verbose basic/BasicTest platform.xml basic/basicDeployment.xml
\endverbatim

Note that you may have to adjust the "coro.stacksPerThread"
configuration option to run large simulations. The default is 100 and
you want to increase it to run more processes.
\verbatim
$ $PATH_TO_COROUTINE_JVM/java -Dcoro.stacksPerThread=$STACKS_NUMBER -cp .:../simgrid.jar basic/BasicTest platform.xml basic/basicDeployment.xml
\endverbatim

If you feel limited in the amount of processes you can run, give a try
to this command:
\verbatim 
sysctl -w vm.max_map_count = 131072
\endverbatim
 */
