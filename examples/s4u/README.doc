S4U (Simgrid for you) is the next interface of SimGrid, expected to be released with SimGrid 4.0.

Even if it is not completely rock stable yet, it may well already fit
your needs. You are welcome to try it and report any interface
glitches that you see. Be however warned that the interface may change
until the final release.  You will have to adapt your code on the way.

This file follows the Doxygen syntax to be included in the
documentation, but it should remain readable directly.

/** 
 @defgroup s4u_examples S4U examples
 @ingroup s4u_api
 @brief Find the S4U example fitting your needs in the archive.

  - @ref s4u_ex_basics
  - @ref s4u_ex_activities
  - @ref s4u_ex_actors
  - @ref s4u_ex_synchro
  - @ref s4u_ex_actions
  - @ref s4u_ex_platf
  - @ref s4u_ex_io
  - @ref s4u_ex_energy

TODO: document here the examples about plugins

@section s4u_ex_basics Basics of SimGrid simulation

  - <b>Creating actors:</b> @ref examples/s4u/actor-create/s4u-actor-create.cpp and 
    @ref examples/s4u/actor-create/s4u-actor-create_d.xml \n
    Shows how to start your actors to populate your simulation.

  - <b>Ping Pong</b>: @ref examples/s4u/app-pingpong/s4u-app-pingpong.cpp\n
    This simple example just sends one message back and forth.
    The tesh file laying in the directory show how to start the simulator binary, highlighting how to pass options to 
    the simulators (as detailed in Section \ref options). 

  - <b>Token ring:</b> @ref examples/s4u/app-token-ring/s4u-app-token-ring.cpp \n
    Shows how to implement a classical communication pattern, where a token is exchanged along a ring to reach every
    participant.

  - <b>Master Workers:</b> @ref examples/s4u/app-masterworker/s4u-app-masterworker.cpp \n
    Another good old example, where one Master process has a bunch of task to dispatch to a set of several Worker 
    processes. 
    
@section s4u_ex_activities Activities on Resources (communications and executions)

@subsection s4u_ex_activity_comm Communications (using the network)

 - <b>Basic asynchronous communications</b>. 
   @ref examples/s4u/async-wait/s4u-async-wait.cpp \n
   Illustrates how to have non-blocking communications, that are
   communications running in the background leaving the process free
   to do something else during their completion. The main functions
   involved are @ref simgrid::s4u::Mailbox::put_async and 
   @ref simgrid::s4u::Comm::wait().

 - <b>Waiting for all communications in a set</b>.
   @ref examples/s4u/async-waitall/s4u-async-waitall.cpp\n
   The @ref simgrid::s4u::Comm::wait_all() function is useful when you want to block
   until all activities in a given set have completed.

 - <b>Waiting for the first completed communication in a set</b>.
   @ref examples/s4u/async-waitany/s4u-async-waitany.cpp\n
   The @ref simgrid::s4u::Comm::wait_any() function is useful when you want to block
   until one activity of the set completes, no matter which terminates
   first.    

@subsection s4u_ex_activity_exec Executions (using the CPU)

  - <b>Basic execution</b>.
    @ref examples/s4u/exec-basic/s4u-exec-basic.cpp \n
    The computations done in your program are not reported to the
    simulated world, unless you explicitely request the simulator to pause
    the actor until a given amount of flops gets computed on its simulated
    host. Some executions can be given an higher priority so that they
    get more resources.

@section s4u_ex_actors Acting on Actors

  - <b>Creating actors</b>. 
    @ref examples/s4u/actor-create/s4u-actor-create.cpp \n
    Most actors are started from the deployment XML file, but there is other methods.
    This example show them all.

  - <b>Daemonize actors</b>
    @ref examples/s4u/actor-daemon/s4u-actor-daemon.cpp \n
    Some actors may be intended to simulate daemons that run in background. This example show how to transform a regular
    actor into a daemon that will be automatically killed once the simulation is over. 

  - <b>Suspend and Resume actors</b>.
    @ref examples/s4u/actor-suspend/s4u-actor-suspend.cpp \n
    Actors can be suspended and resumed during their executions
    thanks to the @ref simgrid::s4u::Actor::suspend and @ref simgrid::s4u::Actor::resume methods.

  - <b>Kill actors</b>.
    @ref examples/s4u/actor-kill/s4u-actor-kill.cpp \n
    Actors can forcefully stop other actors with the @ref
    simgrid::s4u::Actor::kill() method.

  - <b>Controling the actor life cycle from the XML</b>.
    @ref examples/s4u/actor-lifetime/s4u-actor-lifetime.cpp 
    @ref examples/s4u/actor-lifetime/s4u-actor-lifetime_d.xml 
    \n
    You can specify a start time and a kill time in the deployment file.

  - <b>Migrating Actors</b>.
    @ref examples/s4u/actor-migration/s4u-actor-migration.cpp \n
    Actors can move or be moved from a host to another with the @ref
    simgrid::s4u::this_actor::migrate() method.

  - <b>Yielding to other actor</b>.
    @ref examples/s4u/actor-yield/s4u-actor-yield.cpp\n
    The simgrid::s4u::this_actor::yield() function interrupts the
    execution of the current actor, leaving a chance to the other actors
    that are ready to run at this timestamp.

@section s4u_ex_synchro Inter-Actor Synchronization 

 - <b>Waiting for the termination of an actor</b> (joining on it)
   @ref examples/s4u/actor-join/s4u-actor-join.cpp \n
   The simgrid::s4u::Actor::join() method allows to block the current
   actor until the end of the receiving actor.

 - <b>Mutex: </b> @ref examples/s4u/mutex/s4u-mutex.cpp \n
   Shows how to use simgrid::s4u::Mutex synchronization objects.

@section s4u_ex_actions Following Workload Traces

This section details how to run trace-driven simulations. It is very
handy when you want to test an algorithm or protocol that only react
to external events. For example, many P2P protocols react to user
requests, but do nothing if there is no such event.

In such situations, you should write your protocol in C++, and separate
the workload that you want to play onto your protocol in a separate
text file. Declare a function handling each type of the events in your
trace, register them using @ref xbt_replay_action_register in your
main, and then run the simulation.

Then, you can either have one trace file containing all your events,
or a file per simulated process: the former may be easier to work
with, but the second is more efficient on very large traces. Check
also the tesh files in the example directories for details.

  - <b>Communication replay</b>.
    @ref examples/s4u/actions-comm/s4u-actions-comm.cpp \n
    Presents a set of event handlers reproducing classical communication
    primitives (asynchronous send/receive at the moment).

  - <b>I/O replay</b>.
    @ref examples/s4u/actions-storage/s4u-actions-storage.cpp \n
    Presents a set of event handlers reproducing classical I/O
    primitives (open, read, close).

@section s4u_ex_platf Interacting with the platform

 - <b>User-defined properties</b>.
   @ref examples/s4u/platform-properties/s4u-platform-properties.cpp and 
   @ref examples/s4u/platform-properties/s4u-platform-properties_d.xml and
   @ref examples/platforms/prop.xml \n
   You can attach arbitrary information to most platform elements from
   the XML file, and then interact with these values from your
   program. Note that the changes are not written into the XML file: they
   will only last until the end of your simulation.
   - simgrid::s4u::Actor::getProperty() and simgrid::s4u::Actor::setProperty()
   - simgrid::s4u::Host::getProperty() and simgrid::s4u::Host::setProperty()
   - simgrid::s4u::Link::getProperty() and simgrid::s4u::Link::setProperty()
   - simgrid::s4u::NetZone::getProperty() and simgrid::s4u::NetZone::setProperty()

@section s4u_ex_io Simulating disks and files

The examples of this section demonstrate how to interact with the
simulated storages. 

SimGrid provides two levels of abstraction. You can either use the 
FileSystem plugin, or interact directly with the disks. At the file
system level, you can open files and interact with them. A write
operation may fail if the disk is already full. Using the direct (low
level) interface, you just specify the amount of data that is written
or read, and this is done unconditionnally. Both levels have
respective advantages, depending on what you want to model.

  - <b>Access to raw storage devices</b>.
    @ref examples/s4u/io-storage-raw/s4u-io-storage-raw.cpp \n
    This example illustrates how to simply read and write data on a
    simulated storage resource.

  - <b>File Management</b>. @ref examples/s4u/io-file-system/s4u-io-file-system.cpp \n
    This example illustrates the use of operations on files
    (read, write, seek, tell, unlink, ...).

  - <b>Remote I/O</b>. 
    @ref examples/s4u/io-file-remote/s4u-io-file-remote.cpp \n
    I/O operations on files can also be done in a remote fashion, 
    i.e. when the accessed disk is not mounted on the caller's host.

@section s4u_ex_energy Simulating the energy consumption

  - <b>Using Pstates on a host</b>
    @ref examples/s4u/energy-pstate/s4u-energy-pstate.cpp and 
    @ref examples/platforms/energy_platform.xml \n
    Show how define a set of pstates for a host and how the current
    pstate can be accessed/changed with @ref simgrid::s4u::Host::getPstateSpeed and @ref simgrid::s4u::Host::setPstate.
    See also the platform XML file for have a details on how to declare the CPU capacity for each pstate.

*/

/**
@example examples/s4u/actions-comm/s4u-actions-comm.cpp
@example examples/s4u/actions-storage/s4u-actions-storage.cpp
@example examples/s4u/actor-create/s4u-actor-create.cpp
@example examples/s4u/actor-create/s4u-actor-create_d.xml
@example examples/s4u/actor-daemon/s4u-actor-daemon.cpp
@example examples/s4u/actor-join/s4u-actor-join.cpp
@example examples/s4u/actor-kill/s4u-actor-kill.cpp
@example examples/s4u/actor-lifetime/s4u-actor-lifetime.cpp 
@example examples/s4u/actor-lifetime/s4u-actor-lifetime_d.xml 
@example examples/s4u/actor-migration/s4u-actor-migration.cpp
@example examples/s4u/actor-suspend/s4u-actor-suspend.cpp
@example examples/s4u/actor-yield/s4u-actor-yield.cpp
@example examples/s4u/async-wait/s4u-async-wait.cpp
@example examples/s4u/async-waitall/s4u-async-waitall.cpp
@example examples/s4u/async-waitany/s4u-async-waitany.cpp
@example examples/s4u/exec-basic/s4u-exec-basic.cpp
@example examples/s4u/app-token-ring/s4u-app-token-ring.cpp
@example examples/s4u/app-masterworker/s4u-app-masterworker.cpp
@example examples/s4u/app-pingpong/s4u-app-pingpong.cpp
@example examples/s4u/energy-pstate/s4u-energy-pstate.cpp
@example examples/s4u/io-file-system/s4u-io-file-system.cpp
@example examples/s4u/io-file-remote/s4u-io-file-remote.cpp
@example examples/s4u/io-storage-raw/s4u-io-storage-raw.cpp \n
@example examples/s4u/mutex/s4u-mutex.cpp
@example examples/s4u/platform-properties/s4u-platform-properties.cpp
@example examples/s4u/platform-properties/s4u-platform-properties_d.xml
@example examples/platforms/energy_platform.xml
@example examples/platforms/prop.xml

*/